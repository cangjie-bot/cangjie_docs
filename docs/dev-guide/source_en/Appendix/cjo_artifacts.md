# CJO Artifacts

This chapter introduces the CJO (Cangjie Object) artifacts generated during the Cangjie programming language compilation process and their related information.

## What are CJO Artifacts

CJO (Cangjie Object) is a binary format AST (Abstract Syntax Tree) file generated by the Cangjie compiler, primarily serving a role similar to C language header files. CJO files contain interface information, type definitions, function declarations, and other metadata of packages, used for semantic checking and type checking during compilation. In addition to interface metadata, CJO files may also contain partial implementation content in certain special scenarios, such as inline functions, some expressions, and other code fragments that need to be expanded during compilation.

## Functions of CJO Files

### 1. Interface Description

CJO files record public interface information of packages, including type definitions, function signatures, constant declarations, etc., similar to the role of header files in C language.

### 2. Compile-time Dependency Resolution

During compilation, the compiler obtains interface information of imported packages through CJO files for semantic checking and type checking, without needing to reparse source code.

### 3. Modular Support

CJO files enable decoupling between modules, allowing separation of package interfaces and implementations, supporting independent compilation and distribution.

### 4. Cross-package Dependency Management

Through CJO files, the compiler can effectively manage dependencies between packages, ensuring type safety and interface consistency.

## Generation of CJO Files

### Automatic Generation During Package Compilation

When compiling packages with `cjc`, corresponding CJO files are automatically generated:

```shell
$ cjc -p mypackage --output-type=staticlib
```

The compiler generates `mypackage.cjo` file and corresponding library files.

### Specifying Output Directory

You can use the [`--output-dir`](compile_options.md#--output-dir-value-frontend) option to specify the output directory for CJO files:

```shell
$ cjc -p mypackage --output-type=staticlib --output-dir ./build
```

### CJO Files for Macro Packages

For [macro packages](../Macro/defining_and_importing_macro_package.md), compilation generates CJO files with macro attributes:

```shell
$ cjc --compile-macro macro_define.cj --output-dir ./target
```

## Usage of CJO Files

### Working with --import-path

CJO files are primarily used with the [`--import-path`](compile_options.md#--import-path-value-frontend) option to specify search paths. Given the following directory structure:

```text
.
├── libs
|   └── myModule
|       ├── log.cjo
|       └── libmyModule.a
└── main.cj
```

You can use CJO files with the following command:

```shell
$ cjc main.cj --import-path ./libs libmyModule.a
```

The compiler uses `./libs/myModule/log.cjo` file for semantic checking and compilation of `main.cj`.

### Usage in CJPM

In the `cjpm.toml` configuration file, you can configure CJO file dependencies through `bin-dependencies`:

```toml
[target.x86_64-unknown-linux-gnu.bin-dependencies]
path-option = ["./test/pro0", "./test/pro1"]

[target.x86_64-unknown-linux-gnu.bin-dependencies.package-option]
"pro0.xoo" = "./test/pro0/pro0.xoo.cjo"
"pro0.yoo" = "./test/pro0/pro0.yoo.cjo"
```

### Dependency Scanning

You can use the [`--scan-dependency`](compile_options.md#--scan-dependency-frontend) option to scan dependency relationships of CJO files:

```shell
$ cjc --scan-dependency mypackage.cjo
```

## Characteristics of CJO Files

### 1. Binary AST Format

CJO files use binary format to store abstract syntax tree information, providing higher parsing efficiency compared to text format.

### 2. Complete Interface Information

CJO files contain complete package interface information, including type definitions, function signatures, visibility, and other metadata.

### 3. Compiler Version Compatibility

Since the LTS version, the Cangjie compiler promises backward compatibility, where subsequent compiler versions can correctly handle CJO files generated by previous versions. Before the LTS version, CJO files generated by different compiler versions may have compatibility issues.

### 4. Macro Information Support

For macro packages, CJO files carry macro attribute information, supporting compile-time macro expansion.

## Usage Recommendations

### 1. Using CANGJIE_PATH Environment Variable

You can specify CJO file search paths by setting the [`CANGJIE_PATH`](compile_options.md#--import-path-value-frontend) environment variable, with [`--import-path`](compile_options.md#--import-path-value-frontend) option having higher priority.

### 2. Binary Library Distribution

Distribute CJO files along with corresponding library files (.a or .so) to provide binary dependencies for other modules.

### 3. Version Compatibility Management

Since the LTS version, the Cangjie compiler provides backward compatibility guarantee, where new compiler versions can correctly handle CJO files generated by previous versions. Before the LTS version, it's recommended to regenerate CJO files after compiler upgrades.

### 4. Path Management

Use the [`--trimpath`](compile_options.md#--trimpath-value-frontend) option to remove path prefix information from CJO files for cross-environment usage.

## Frequently Asked Questions

### Q: What if CJO files are out of sync with source files?

A: Delete outdated CJO files and recompile the corresponding packages.

### Q: How to view dependency information of CJO files?

A: Use [`cjc --scan-dependency`](compile_options.md#--scan-dependency-frontend) `mypackage.cjo` command to view dependency relationships.

### Q: Why can't CJO files be found?

A: Check if [`--import-path`](compile_options.md#--import-path-value-frontend) settings are correct and ensure CJO files are in the specified search paths.

### Q: Can CJO files be used across platforms?

A: CJO files mainly contain interface information and can typically be used across platforms, but it's recommended to regenerate them on target platforms.

## Related Options

The following compilation options are related to CJO file generation and usage:

- [`--import-path <value>`](compile_options.md#--import-path-value-frontend): Specifies search paths for imported module AST files
- [`--output-dir <value>`](compile_options.md#--output-dir-value-frontend): Controls the save directory for CJO files
- [`-p, --package`](compile_options.md#--package--p-frontend): Automatically generates corresponding CJO files when compiling packages
- [`--scan-dependency`](compile_options.md#--scan-dependency-frontend): Scans dependency relationships of CJO files
- `--compile-macro`: Compiles macro packages to generate CJO files with macro attributes
- [`--trimpath <value>`](compile_options.md#--trimpath-value-frontend): Removes path prefix information from CJO files

## Notes

1. **Search Paths**: Ensure CJO file search paths are correctly set through [`--import-path`](compile_options.md#--import-path-value-frontend) or [`CANGJIE_PATH`](compile_options.md#--import-path-value-frontend).

2. **File Synchronization**: CJO files must stay synchronized with corresponding library files; version mismatches may cause compilation errors.

3. **Version Compatibility**: Since the LTS version, the Cangjie compiler promises backward compatibility, where new versions can correctly handle CJO files generated by previous versions. Before LTS versions, it's recommended to regenerate CJO files after compiler upgrades.

4. **Macro Package Handling**: CJO files for macro packages need to be used with corresponding dynamic library files, maintaining consistent path settings.

5. **Dependency Resolution**: The compiler performs semantic checking through CJO files, ensuring imported package interface information is complete and accurate.